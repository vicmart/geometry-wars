/**
 * When you import the library Two.is a window level class that serves as
 *  the main interaction point for the project. It exposes a number of
 *  methods and properties. These make it possible to draw, but also
 *  afford other capabilities such as augmenting the drawing space. 
 * Below are the documented properties and features of the Two.class.
 *  Unless specified methods return their instance of Two.for the purpose of chaining.
 */
export = Two

declare class Two {
    /**A number representing how many subdivisions should be present during curve calculations. */
    static Resolution: number;
    /**A running list of all instances created on the page. */
    static Instances: Array<any>;
    type: Two.Types;
    root: any;
    Version: string;
    Resolution: number;
    Instances: any[];

    width: number;
    height: number;
    frameCount: number;
    timeDelta: number;
    playing: boolean;
    scene: Two.Group;
    Vector: Two.VectorConstructor;
    Path: Function;
    RoundedRectangle: Function;
    Rectangle: Function;
    Star: Function;
    Polygon: Function;
    Group: Function;
    Commands: Two.Commands;
     /**
     * A Two.Anchor can take initial positions of x and y to orient the point. 
     * lx and ly describe where the left control point will reside. Likewise rx 
     * and ry describe where the right control point will reside. Finally, the 
     * command describes what action the renderer will take once rendering. A 
     * more detailed description of commands can be found on the w3c and the 
     * available commands in Two.js can be found under Two.Commands.
     * @param x initial x
     * @param y initial y
     * @param lx left control point x
     * @param ly left control point y
     * @param rx right control point x
     * @param ry right control point y
     * @param command a Two.Commands
     */
    Anchor: Two.AnchorConstructor;
    Stop: Function;
    LinearGradient: Function;
    RadialGradient: Function;
    Text: Function;
    /**
     * Create a new instance of Two.where params is a JavaScript object with several optional parameters listed below:
     * @param params 
     */
    Two: Two.TwoConstructor

    /**
     * Create a new instance of Two.where params is a JavaScript object with several optional parameters listed below:
     * @param params 
     */
    constructor(params?: Two.ConstructionParams);

    /**
     * Run Two.js in noConflict mode, returning the Two variable to its previous owner. Returns a reference to the Two.class.
     */
    static noConflict();
    /**
     * A Two.js specific custom error handler. Takes a message, string, to display in the console to developers.
     */
    static Error();

    /**
     * A convenient method to append the instance's dom element to the page. 
     * It's required to add the instance's dom element to the page in order to see anything drawn.
     * @param element the dom element we want to append to 
     */
    appendTo(element: HTMLElement): Two;
    /**
     * Draws a line between Two coordinates to the instance's drawing space where x1, y1 are the x,
     *  y values for the first coordinate and x2, y2 are the x, y values for the second coordinate. 
     * It returns a Two.Line object.
     * @param x1 
     * @param y1 
     * @param x2 
     * @param y2 
     */
    makeLine(x1: number, y1: number, x2: number, y2: number): Two.Line;
    /**
     * Draws a rectangle to the instance's drawing space where x, y are the x, y values for the
     *  center point of the rectangle and width, height represents the width and height of the rectangle. 
     * It returns a Two.Rectangle object.
     * @param x 
     * @param y 
     * @param width 
     * @param height 
     */
    makeRectangle(x: number, y: number, width: number, height: number): Two.Rectangl;
    /**
     * Draws a rounded rectangle to the instance's drawing space where x, y are the x, y 
     * values for the center point of the rectangle and width, height represents the 
     * width and height of the rectangle. Lastly, the radius parameter defines what
     *  the miter radius of the rounded corner is. It returns a Two.RoundedRectangle object.
     * @param x 
     * @param y 
     * @param width 
     * @param height 
     * @param radius 
     */
    makeRoundedRectangle(x: number, y: number, width: number, height: number, radius: number): Two.RoundedRectangle;
    /**
     * Draws an arc segment from center point ox, oy with an inner and outer radius of ir, or. 
     * Lastly, you need to supply a start and ending angle sa, ea. Optionally, pass the 
     * resolution for how many points on the arc are desired. It returns a Two.ArcSegment object.
     * @param ox outer x
     * @param oy  outer y
     * @param ir  inner radius
     * @param or  outer radius
     * @param sa start angle in radians ( me thinks)
     * @param ea  end angle in raians ( me thinks )
     * @param res resolution or number of points
     */
    makeArcSegment(ox: number, oy: number, ir: number, or: number, sa: number, ea: number, res: number): Two.ArcSegment;
    /**
     * Draws a circle to the instance's drawing space where x, y are the x, y values for the center
     *  point of the circle and radius is the radius of the circle. It returns a Two.Circle object.
     * @param x 
     * @param y 
     * @param radius 
     */
    makeCircle(x: number, y: number, radius: number): Two.Circle;
    /**
     * Draws an ellipse to the instance's drawing space where x, y are the x, y values for the center 
     * point of the ellipse and width, height are the dimensions of the ellipse. It returns a Two.Ellipse object.
     * @param x 
     * @param y 
     * @param width 
     * @param height 
     */
    makeEllipse(x: number, y: number, width: number, height: number): Two.Ellipse;
    /**
     * Draws a star to the instance's drawing space where ox, oy are the x, y values for the center point 
     * of the star and or, ir are the outer and inner radii for the star, and sides are how many 
     * points the star has. It returns a Two.Star object.
     * @param ox 
     * @param oy 
     * @param or 
     * @param ir 
     * @param sides 
     */
    makeStar(ox: number, oy: number, or: number, ir: number, sides: number): Two.Star;
    /**
    * @description The method accepts any amount of paired x, y values as denoted by the series above. 
    * It then checks to see if there is a final argument, a boolean open, which marks 
    * whether or not the shape should be open. If true the curve will have Two clear endpoints,
    * otherwise it will be closed.
    * This method also recognizes the format Two.makeCurve(points, open) where points is an array of 
    * Two.Anchor's and open is an optional boolean describing whether or not to expose endpoints.
    * It is imperative if you generate curves this way to make the list of points Two.Anchor's.
    * @param points: an array of numbers [ x1, y1, x2, y2, ....]
    * @param open: should endpoints be exposed
    */
    makeCurve(points: number[], open: boolean): Two.Path;
    /**
    * @description The method accepts any amount of paired x, y values as denoted by the series above. 
    * It then checks to see if there is a final argument, a boolean open, which marks 
    * whether or not the shape should be open. If true the curve will have Two clear endpoints,
    * otherwise it will be closed.
    * This method also recognizes the format Two.makeCurve(points, open) where points is an array of 
    * Two.Anchor's and open is an optional boolean describing whether or not to expose endpoints.
    * It is imperative if you generate curves this way to make the list of points Two.Anchor's.
    * @param points: an array of numbers [ x1, y1, x2, y2, ....]
    * @param open: should endpoints be exposed
    */
    makePath(points: number[], open: boolean): Two.Path;
    makePolygon(x1: number, y1: number, x2: number, y2: number, open: boolean): Two.Polygon;
    /**
     * Adds a group to the instance's drawing space. While a group does not have any visible
     *  features when rendered it allows for nested transformations on shapes. 
     * See Two.Group for more information. It accepts an array of objects, Two.Paths or Two.Groups.
     *  As well as a list of objects as the arguments, Two.makeGroup(o1, o2, oN). 
     * It returns a Two.Group object.
     * @param objects array of shapes to group
     * @return the new group
     */
    makeGroup(objects: Array<Two.Shape>): Two.Group;
    /**
     * Bind an event, string, to a callback function. Passing "all" will bind the callback to all events. 
     * Inherited from Backbone.js.
     * @param event 
     * @param callback 
     */
    bind(event: Two.Events, callback: (arg?: Array<any>) => void);
    /**
     * Remove one or many callback functions. If callback is null it removes all callbacks for an event.
     * If the event name is null, all callback functions for the instance are removed. 
     * This is highly discouraged. Inherited from Backbone.js.
     * @param event 
     * @param callback 
     */
    unbind(event: Two.Events, callback: (arg?: Array<any>) => void);
    /**
     * Reads an svg node and draws the svg object by creating Two.Paths and Two.Groups from 
     * the reference. It then adds it to the instance's drawing space.
     * @param svgNode the svg node we want to interpret
     * @return Two.Group object
     */
    interpret(svgNode: any): Two.Group;
    /**
     * This method adds the instance to the requestAnimationFrame loop. In affect enabling animation for this instance.
     */
    play(): void;
    /**
     * This method removes the instance from the requestAnimationFrame loop. In affect halting animation for this instance.
     */
    pause(): void;
    /**
     * This method updates the dimensions of the drawing space, increments the tick for animation, 
     * and finally calls Two.render(). When using the built-in requestAnimationFrame hook, Two.play(), 
     * this method is invoked for you automatically.
     */
    update(): void;
    /**
     * This method makes the instance's renderer draw. It should be unnecessary to invoke this yourself at anytime.
     */
    render(): void;
    /**
     * Add one or many shapes / groups to the instance. Objects can be added as arguments, Two.add(o1, o2, oN), or as an array depicted above.
     */
    add(): void;
    /**
     * Remove one or many shapes / groups from the instance. Objects can be
     *  removed as arguments, Two.remove(o1, o2, oN), or as an array depicted above.
     */
    remove(): void;
    /**
     * Removes all objects from the instance's scene. If you intend to have 
     * the browser garbage collect this, don't forget to delete the references in your application as well.
     */
    clear();

}

declare namespace Two {
    export namespace Text {
        export interface Properties {
            value?: string, family?: string, size?: number, leading?: number, alignment?: string, linewidth?: number, style?: string,
            weight?: number, decoration?: string, baseline?: string, opacity?: number, visible?: boolean, fill?: string, stroke?: string
        }
    }
    export namespace Path {
        export interface Properties {
            fill?: string, stroke?: string; linewidth?: number, opacity?: number, visible?: boolean, cap?: string, join?: string, mitre?: number,
            closed?: boolean, curved?: boolean, automatic?: boolean, beginning?: boolean, ending?: boolean
        }
    }
    /**
     * A collection of utility functions and variables used throughout the project. This is where
     *  much of the algorithmic computation lies: computing curve handles, subdividing cubic
     *  bezier curves, interpretting svg nodes. Because of its complexity it's
     * encouraged to look at the source code for further information.
     */
    export namespace Utils{

    }
    /**A list of renderer specific application properties. */
    export enum Properties { hierarchy = 'hierarchy', demotion = 'demotion' }
    /**
     * A list of commands that dictate how the various renderers draw Two.Anchors.
     */
    export enum Commands {
        //M, L, C, Z
        move = 'move',
        line = 'line',
        curve = 'curve',
        close = 'close'
    }
    /**
     * A list of applicable types of rendering contexts. This is used to standardize 
     * the addresses of the various renderers. The types include svg, canvas, and webgl. e.g: Two.Types.svg
     */
    export enum Types {
        webgl = 'WebGLRenderer',
        svg = 'SVGRenderer',
        canvas = 'CanvasRenderer'
    }

    /**
     * A list of actionable events triggered by a given instance. For the most part 
     * these are internal events in order to enable Two-way databinding. 
     * Exceptions include update event on animation loop and resize when the dimensions 
     * of the drawing space change. Related to Two.bind and Two.trigger.
     */
    export enum Events {
        play = 'play',
        pause = 'pause',
        update = 'update',
        render = 'render',
        resize = 'resize',
        change = 'change',
        remove = 'remove',
        insert = 'insert'
    }
    export interface Controls {
        right?: Vector, left?:Vector
    }

    export type TwoConstructor = () => Two;
    // export class Two extends Two{ }

    export type VectorConstructor = (x: number, y: number ) => Vector;
    export class Vector {
        x: number;
        y: number;

        constructor(x: number, y: number)
        set(x: number, y: number);
        copy(v: Vector);
        clear();
        clone();
        add(v1: Vector, v2: Vector);
        addSelf(v: Vector);
        subSelf(v: Vector);
        multiplySelf(v: Vector);
        multiplyScalar(v: Vector);
        divideScalar(v: Vector);
        negate(v: Vector);
        dot(v: Vector);
        lengthSqaured();
        normalize();
        distanceTo(v: Vector);
        distanceToSquared(v: Vector);
        setLength(length: number);
        equals(v: Vector);
        lerp(v: Vector, t: number);
        isZero();
    }
    export type AnchorConstructor = (x: number, y: number, lx: number, ly: number, rx: number, ry: number, command: Commands) => Anchor;
    /**
     * @description
     * Taken from the Adobe Illustrator nomenclature a Two.Anchor represents an anchor point in Two.js. 
     * This class delineates to the renderer what action to take when plotting points. 
     * It inherits all properties and methods from Two.Vector. As a result, Two.Anchor 
     * can be used as such. Depending on its command, anchor points may or may not have 
     * corresponding control points to describe how their bezier curves should be rendered.
     */
    export class Anchor extends Vector {
        command: Commands;
        controls: Controls;

        constructor(x: number, y: number, lx: number, ly: number, rx: number, ry: number, command: Commands);

        listen();
        ignore();
    }


    export class Polygon extends Path {
        vertices: Collection;
        constructor(x: number, y: number, radius: number, sides: number);
    }

    export class Shape {
        isShape: boolean;
        id: string;
        classList: any[];
        translation: Vector;
        rotation: number;
        scale: number;

        addTo(group: Group);
        clone();
        flagReset();
    }

    export class Group extends Shape {
        children: Array<any>;
        mask: Path;

        /**
         * Add objects to the group.
         */
        add(...objects: any[]);
        /**
         * Remove objects from the group.
         */
        remove(...objects: any[]);
        /**
        * Export the data from the instance of Two.Group into a plain JavaScript
        * object. This also makes all children plain JavaScript objects. Great
        * for turning into JSON and storing in a database.
        */
        toObject();
        /**
        * Anchor all children to the upper left hand corner
        * of the group.
        */
        corner();
        /**
        * Anchors all children around the center of the group,
        * effectively placing the shape around the unit circle.
        */
        center();
        /**
        * Recursively search for id. Returns the first element found.
        * Returns null if none found.
        */
        getById(id: string);
        /**
        * Recursively search for classes. Returns an array of matching elements.
        * Empty array if none found.
        */
        getByClassName(id: String);
        /**
         * Recursively search for children of a specific type,
         * e.g. Two.Polygon. Pass a reference to this type as the param.
         * Returns an empty array if none found.
         */
        getByType(type: any);
        /**
         * Trickle down of noFill
         */
        noFill();
        /**
         * Trickle down of noStroke
         */
        noStroke();
        /**
         * Trickle down subdivide
         */
        subdivide();

    }

    export class Stop {
        offset: number;
        color: string;
        opacity: number;
        constructor(offset: number, color: string, opacity: number);

    }

    export class Star extends Path {
        constructor(x: number, y: number, or: number, sides: number);
    }

    export class Circle extends Path {
        constructor(ox: number, oy: number, r: number)
    }
    export class ArcSegment extends Path {
        constructor(ox: number, oy: number, ir: number, or: number, sa: number, ea: number, res: number)
    }
    export class Ellipse extends Path {
        constructor(x: number, y: number, width: number, height: number);
    }

    export class Rectangl extends Path {
        constructor(x: number, y: number, width: number, height: number);
    }

    export class RoundedRectangle extends Path {
        constructor(x: number, y: number, width: number, height: number, radius: number);
    }
    /**
     * This is the base class for creating all drawable shapes in Two.js. 
     * Unless specified methods return their instance of Two.Path for the purpose of chaining.
     */
    export class Path extends Shape {
        id: string;
        closed: boolean;
        curved: boolean;
        automatic: boolean;
        beginning: number;
        ending: number;
        clip: boolean;
        translation: Two.Vector;
        rotation: number; // radian
        scale: number;
        visible: boolean;
        parent: Two.Group;
        vertices: Collection;
        stroke: string;
        fill: string;
        linewidth: number;
        opacity: number;
        cap: string;
        join: string;
        miter: number;


        /**
         * A path takes an array of vertices which are made up of Two.Anchors. This is essential
         *  for the Two-way databinding. It then takes Two booleans, closed and curved which
         *  delineate whether the shape should be closed (lacking endpoints) and whether 
         * the shape should calculate curves or straight lines between the vertices. 
         * Finally, manual is an optional argument if you'd like to override the default behavior
         *  of Two.js and handle anchor positions yourself. Generally speaking, this isn't 
         * something you need to deal with, although some great usecases arise from this 
         * customability, e.g: advanced curve manipulation.
         * @param vertices vertices of the path 
         * @param closed whether the path is closed or open
         * @param curved whether the path is curved
         * @param manual 
         */
        constructor(vertices: Array<Anchor>, closed: boolean, curved: boolean, manual: boolean);

        /**
        * Based on closed / curved and sorting of vertices plot where all points
        * should be and where the respective handles should be too.
        */
        plot();
        /**
        * Given a float `t` from 0 to 1, return a point or assign a passed `obj`'s
        * coordinates to that percentage on this Two.Path's curve.
        */
        getPointAt(t: number, obj: Vector);

        noStroke();
        noFill();
        corner();
        subdivide();
        center();
        remove();
        toObject();

    }
    export class Line extends Path {
        constructor(x1: number, y1: number, x2: number, y2: number)
    }

    export class LinearGradient {
        left: Vector;
        right: Vector;
        spread: string;
        stops: Array<Stop>;

        constructor(x1: number, x2: number, y1: number, y2: number, stops: Array<Stop>);
    }

    export class RadialGradient {
        center: Vector;
        radius: number;
        focal: Vector;
        spread: string;
        stops: Array<Stop>;

        constructor(x: number, y: number, radius: number, stops: Array<Stop>, fx: number, fy: number);
    }

    export class Text extends Shape {
        value: string;
        family: string;
        size: number;
        leading: number;
        alignment: string;
        style: string;
        weight: number;
        decoration: string;
        baseline: string;
        visible: boolean;
        constructor(message: string, x: number, y: number, styles: Text.Properties)
    }
    
    export interface Collection extends Array<any> { }
    
    export interface ConstructionParams {
        type?: Two.Types;
        width?: number;
        height?: number;
        autostart?: boolean;
        fullscreen?: boolean;
    }
}
